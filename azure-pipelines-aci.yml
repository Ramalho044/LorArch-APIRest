trigger:
  branches:
    include:
      - master
      - main

pr:
  branches:
    include:
      - master
      - main

pool:
  vmImage: 'ubuntu-latest'

name: $(Date:yyyyMMdd).$(Rev:r)

variables:
  appName: 'lorarch-app'
  resourceGroup: 'LorArch'
  location: 'eastus'
  acrName: 'acrlorch'
  acrLoginServer: 'acrlorch.azurecr.io'
  imageRepository: 'fiap/lorarch'
  dockerRegistryServiceConnection: 'sc-acr-lorch'
  azureServiceConnection: 'sc-azure-lorch'

# ========================================================
# STAGES
# ========================================================
stages:

# ========================================================
#  STAGE 1 - CI: BUILD + TEST + DOCKER BUILD & PUSH
# ========================================================
- stage: CI
  displayName: 'CI ‚Äî Build, Test, Docker build & Push'
  jobs:
    - job: build
      displayName: 'Job: Build & Test Java'
      steps:

        # 1Ô∏è‚É£ Checkout do reposit√≥rio
        - checkout: self
          fetchDepth: 1

        # 2Ô∏è‚É£ Instalar Java 21
        - task: JavaToolInstaller@0
          displayName: 'Instalar Java 21'
          inputs:
            versionSpec: '21'
            jdkArchitectureOption: 'x64'
            jdkSourceOption: 'PreInstalled'

        # 3Ô∏è‚É£ Cache Gradle
        - task: Cache@2
          displayName: 'Cache Gradle'
          inputs:
            key: 'gradle | "$(Agent.OS)" | **/gradle-wrapper.properties'
            restoreKeys: gradle | "$(Agent.OS)"
            path: ~/.gradle

        # 4Ô∏è‚É£ Permitir execu√ß√£o do gradlew (corrige erro 126)
        - bash: chmod +x gradlew
          displayName: 'Permitir execu√ß√£o do Gradle Wrapper'

        # 5Ô∏è‚É£ Subir SQL Server no container local (para testes)
        - bash: |
            set -euo pipefail
            docker rm -f mssql_ci 2>/dev/null || true

            echo "Subindo SQL Server para testes locais..."
            docker run -d --name mssql_ci \
              -e 'ACCEPT_EULA=Y' \
              -e 'MSSQL_SA_PASSWORD=Str0ng_Passw0rd!' \
              -p 1433:1433 \
              mcr.microsoft.com/mssql/server:2022-latest

            echo "Esperando SQL iniciar..."
            for i in {1..30}; do
              if docker logs mssql_ci 2>&1 | grep -q "SQL Server is now ready for client connections"; then
                echo "‚úÖ SQL pronto."
                break
              fi
              sleep 5
              echo "Aguardando... $i"
            done

            echo "Configurando banco lorarch_ci..."
            SQLCMD_PATH=$(docker exec mssql_ci bash -lc 'command -v /opt/mssql-tools18/bin/sqlcmd || command -v /opt/mssql-tools/bin/sqlcmd')
            docker exec mssql_ci ${SQLCMD_PATH} -C \
              -S localhost -U sa -P 'Str0ng_Passw0rd!' \
              -Q "IF DB_ID('lorarch_ci') IS NULL CREATE DATABASE lorarch_ci;"
          displayName: 'Subir SQL Server (CI) ‚Äî sem SSL'

        # 6Ô∏è‚É£ Rodar testes unit√°rios
        - script: ./gradlew clean test --no-daemon
          displayName: 'Rodar Testes'
          env:
            SPRING_DATASOURCE_URL: 'jdbc:sqlserver://localhost:1433;databaseName=lorarch_ci;encrypt=true;trustServerCertificate=true;'
            SPRING_DATASOURCE_USERNAME: 'sa'
            SPRING_DATASOURCE_PASSWORD: 'Str0ng_Passw0rd!'

        # 7Ô∏è‚É£ Publicar resultados de teste (JUnit)
        - task: PublishTestResults@2
          displayName: 'Publicar resultados de teste'
          inputs:
            testResultsFormat: 'JUnit'
            testResultsFiles: '**/TEST-*.xml'
            searchFolder: '$(System.DefaultWorkingDirectory)'
            failTaskOnFailedTests: true

        # 8Ô∏è‚É£ Gerar artefato JAR
        - script: ./gradlew bootJar --no-daemon
          displayName: 'Gerar artefato JAR'

        # 9Ô∏è‚É£ Preparar artefato para Docker
        - bash: |
            set -e
            JAR=$(ls build/libs/*.jar | head -n1)
            echo "Usando JAR: $JAR"
            mkdir -p drop
            cp "$JAR" drop/app.jar
          displayName: 'Preparar artefato para Docker'

        # üîü Publicar artefato
        - task: PublishBuildArtifacts@1
          displayName: 'Publicar artefato (drop)'
          inputs:
            pathToPublish: 'drop'
            artifactName: 'drop'

        # 11Ô∏è‚É£ Build e Push da imagem Docker para o ACR
        - task: Docker@2
          displayName: 'Build & Push da imagem Docker ‚Üí ACR'
          inputs:
            containerRegistry: '$(dockerRegistryServiceConnection)'
            repository: '$(imageRepository)'
            command: 'buildAndPush'
            Dockerfile: 'Dockerfile'
            buildContext: '$(System.DefaultWorkingDirectory)'
            tags: |
              $(Build.BuildId)
              latest

# ========================================================
#  STAGE 2 - CD: DEPLOY NO AZURE CONTAINER INSTANCE
# ========================================================
- stage: CD
  displayName: 'CD ‚Äî Deploy no Azure Container Instance (ACI)'
  dependsOn: CI
  condition: succeeded()

  jobs:
    - job: deploy
      displayName: 'Job: Deploy ACI'
      steps:

        - task: AzureCLI@2
          displayName: 'Criar / Atualizar Container no ACI'
          inputs:
            azureSubscription: '$(azureServiceConnection)'
            scriptType: bash
            scriptLocation: inlineScript
            inlineScript: |
              set -e

              IMAGE="$(acrLoginServer)/$(imageRepository):$(Build.BuildId)"
              DNS_LABEL="$(echo $(appName) | tr '[:upper:]' '[:lower:]')"

              echo "Criando container $appName com imagem $IMAGE..."

              if az container show -g $(resourceGroup) -n $(appName) &>/dev/null; then
                echo "Container existente. Deletando..."
                az container delete -g $(resourceGroup) -n $(appName) --yes
              fi

              az container create \
                --name $(appName) \
                --resource-group $(resourceGroup) \
                --location $(location) \
                --image ${IMAGE} \
                --cpu 1 --memory 1.5 \
                --restart-policy Always \
                --ports 8080 \
                --dns-name-label ${DNS_LABEL} \
                --registry-login-server $(acrLoginServer) \
                --environment-variables \
                    SPRING_PROFILES_ACTIVE=prod \
                    SERVER_PORT=8080 \
                --secure-environment-variables \
                    SPRING_DATASOURCE_URL=$(DB_URL) \
                    SPRING_DATASOURCE_USERNAME=$(DB_USER) \
                    SPRING_DATASOURCE_PASSWORD=$(DB_PASSWORD)

              echo "Aguardando container ficar Running..."
              for i in {1..40}; do
                STATE=$(az container show -g $(resourceGroup) -n $(appName) --query "instanceView.state" -o tsv)
                echo "Estado: $STATE"
                [ "$STATE" = "Running" ] && break
                sleep 6
              done

              FQDN=$(az container show -g $(resourceGroup) -n $(appName) --query "ipAddress.fqdn" -o tsv)
              echo "Aplica√ß√£o dispon√≠vel em: http://$FQDN:8080"

              echo "Validando health-check..."
              for i in {1..30}; do
                code=$(curl -s -o /dev/null -w "%{http_code}" "http://$FQDN:8080/actuator/health" || true)
                echo "Tentativa $i -> HTTP $code"
                [ "$code" = "200" ] && echo "‚úÖ Health OK!" && exit 0
                sleep 5
              done

              echo "‚ö†Ô∏è Health n√£o ficou 200. Logs recentes:"
              az container logs -g $(resourceGroup) -n $(appName) --tail 50 || true
              exit 1
