trigger:
  branches:
    include:
      - master
      - main

pr:
  branches:
    include:
      - master
      - main

pool:
  vmImage: 'ubuntu-latest'

name: $(Date:yyyyMMdd).$(Rev:r)

variables:
  appName: 'lorarch-app'
  resourceGroup: 'LorArch'
  location: 'eastus'
  acrName: 'acrlorch'
  acrLoginServer: 'acrlorch.azurecr.io'
  imageRepository: 'fiap/lorarch'
  dockerRegistryServiceConnection: 'sc-acr-lorch'
  azureServiceConnection: 'sc-azure-lorch'

# ========================================================
#  STAGE 1 - CONTINUOUS INTEGRATION (BUILD + TEST + DOCKER)
# ========================================================
stages:
- stage: CI
  displayName: 'CI — Build, Test, Docker build & Push'
  jobs:
  - job: build
    displayName: 'Job: Build & Test Java'
    steps:
      # Checkout
      - checkout: self
        fetchDepth: 1

      # Java 21
      - task: JavaToolInstaller@0
        displayName: 'Instalar Java 21'
        inputs:
          versionSpec: '21'
          jdkArchitectureOption: 'x64'
          jdkSourceOption: 'PreInstalled'

      # Cache Gradle
      - task: Cache@2
        displayName: 'Cache Gradle'
        inputs:
          key: 'gradle | "$(Agent.OS)" | **/gradle-wrapper.properties'
          restoreKeys: |
            gradle | "$(Agent.OS)"
          path: ~/.gradle

      # Permissão para o gradlew
      - script: chmod +x ./gradlew
        displayName: 'Permitir execução do gradlew'

      # Testes + Jacoco
      - script: ./gradlew clean test jacocoTestReport --no-daemon
        displayName: 'Rodar Testes + Jacoco'

      - task: PublishTestResults@2
        displayName: 'Publicar resultados de teste'
        inputs:
          testResultsFormat: 'JUnit'
          testResultsFiles: '**/TEST-*.xml'
          searchFolder: '$(System.DefaultWorkingDirectory)'
          failTaskOnFailedTests: true

      - task: PublishCodeCoverageResults@2
        displayName: 'Publicar relatório Jacoco'
        inputs:
          codeCoverageTool: 'JaCoCo'
          summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/build/reports/jacoco/test/jacocoTestReport.xml'
          reportDirectory: '$(System.DefaultWorkingDirectory)/**/build/reports/jacoco/test/html'
          failIfCoverageEmpty: false

      # Build do JAR
      - script: ./gradlew bootJar --no-daemon
        displayName: 'Gerar artefato JAR'

      # Copia para pasta drop
      - bash: |
          set -e
          JAR=$(ls build/libs/*.jar | head -n1)
          mkdir -p drop
          cp "$JAR" drop/app.jar
        displayName: 'Preparar artefato para Docker'

      - task: PublishBuildArtifacts@1
        displayName: 'Publicar artefato (drop)'
        inputs:
          pathToPublish: 'drop'
          artifactName: 'drop'

      # Build & push da imagem Docker
      - task: Docker@2
        displayName: 'Build & Push da imagem Docker → ACR'
        inputs:
          containerRegistry: '$(dockerRegistryServiceConnection)'
          repository: '$(imageRepository)'
          command: 'buildAndPush'
          Dockerfile: 'Dockerfile'
          buildContext: '$(System.DefaultWorkingDirectory)'
          tags: |
            $(Build.BuildId)
            latest

# ========================================================
#  STAGE 2 - CONTINUOUS DEPLOYMENT (AZURE ACI)
# ========================================================
- stage: CD
  displayName: 'CD — Deploy no Azure Container Instance (ACI)'
  dependsOn: CI
  condition: succeeded()

  jobs:
  - job: deploy
    displayName: 'Job: Deploy ACI'
    steps:
      - task: AzureCLI@2
        displayName: 'Criar / Atualizar Container no ACI'
        inputs:
          azureSubscription: '$(azureServiceConnection)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            set -e

            IMAGE="$(acrLoginServer)/$(imageRepository):$(Build.BuildId)"
            DNS_LABEL="$(echo $(appName) | tr '[:upper:]' '[:lower:]')"

            echo "Imagem: $IMAGE"
            echo "DNS label: $DNS_LABEL"

            # Remove container antigo, se existir
            if az container show -g "$(resourceGroup)" -n "$(appName)" &>/dev/null; then
              echo "Apagando container antigo..."
              az container delete -g "$(resourceGroup)" -n "$(appName)" --yes
            fi

            echo "Criando container no ACI..."
            az container create \
              --name "$(appName)" \
              --resource-group "$(resourceGroup)" \
              --location "$(location)" \
              --image "$IMAGE" \
              --os-type Linux \
              --cpu 1 \
              --memory 1.5 \
              --ports 8080 \
              --dns-name-label "$DNS_LABEL" \
              --registry-login-server "$(acrLoginServer)" \
              --registry-username "$(ACR_USERNAME)" \
              --registry-password "$(ACR_PASSWORD)" \
              --restart-policy Always \
              --environment-variables \
                  SPRING_PROFILES_ACTIVE=prod \
                  SERVER_PORT=8080 \
              --secure-environment-variables \
                  SPRING_DATASOURCE_URL="$(DB_URL)" \
                  SPRING_DATASOURCE_USERNAME="$(DB_USER)" \
                  SPRING_DATASOURCE_PASSWORD="$(DB_PASSWORD)"

            echo "Aguardando container iniciar..."
            for i in {1..40}; do
              STATE=$(az container show -g "$(resourceGroup)" -n "$(appName)" --query "instanceView.state" -o tsv)
              echo "Estado: $STATE"
              if [ "$STATE" = "Running" ]; then
                break
              fi
              sleep 6
            done

            FQDN=$(az container show -g "$(resourceGroup)" -n "$(appName)" --query "ipAddress.fqdn" -o tsv)
            echo "Aplicação (quando saudável) em: http://$FQDN:8080"

            echo "Verificando health-check (sem derrubar a pipeline)..."
            for i in {1..30}; do
              code=$(curl -s -o /dev/null -w "%{http_code}" "http://$FQDN:8080/actuator/health" || true)
              echo "Tentativa $i -> HTTP $code"
              if [ "$code" = "200" ]; then
                echo "Health OK!"
                exit 0
              fi
              sleep 5
            done

            echo "Health não respondeu 200. Confira os logs no portal do Azure se o professor implicar."
            exit 0
